<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 15. Repeated Planning</title><link rel="stylesheet" type="text/css" href="css/jbossorg.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="OptaPlanner User Guide"/><link rel="up" href="index.html" title="OptaPlanner User Guide"/><link rel="prev" href="ch14.html" title="Chapter 14. Benchmarking And Tweaking"/><link rel="next" href="ch16.html" title="Chapter 16. Integration"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><p id="title"><a href="http://www.jboss.org" class="site_href"><strong>JBoss.org</strong></a><a href="http://docs.jboss.org/" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch14.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch16.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 15. Repeated Planning"><div class="titlepage"><div><div><h2 class="title"><a id="repeatedPlanning"/>Chapter 15. Repeated Planning</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch15.html#introductionToRepeatedPlanning">15.1. Introduction to Repeated Planning</a></span></dt><dt><span class="section"><a href="ch15.html#backupPlanning">15.2. Backup Planning</a></span></dt><dt><span class="section"><a href="ch15.html#overconstrainedPlanning">15.3. Overconstrained Planning</a></span></dt><dt><span class="section"><a href="ch15.html#continuousPlanning">15.4. Continuous Planning (Windowed Planning)</a></span></dt><dd><dl><dt><span class="section"><a href="ch15.html#immovablePlanningEntities">15.4.1. Immovable Planning Entities</a></span></dt><dt><span class="section"><a href="ch15.html#nonvolatileReplanning">15.4.2. Nonvolatile Replanning to minimize disruption (Semi-movable Planning Entities)</a></span></dt></dl></dd><dt><span class="section"><a href="ch15.html#realTimePlanning">15.5. Real-time Planning</a></span></dt><dd><dl><dt><span class="section"><a href="ch15.html#problemFactChange">15.5.1. <code class="literal">ProblemFactChange</code></a></span></dt><dt><span class="section"><a href="ch15.html#daemon">15.5.2. Daemon: <code class="literal">solve()</code> Does Not Return</a></span></dt></dl></dd></dl></div><div class="section" title="15.1. Introduction to Repeated Planning"><div class="titlepage"><div><div><h2 class="title"><a id="introductionToRepeatedPlanning"/>15.1. Introduction to Repeated Planning</h2></div></div></div><p>The world constantly changes. The problem facts used to create a solution, might change before or during the
    execution of that solution. There are different situations (which can be combined):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><span class="emphasis"><em>Unforeseen fact changes</em></span>: For example: an employee assigned to a shift calls in sick,
        an airplane scheduled to take off has a technical delay, one of the machines or vehicles break down, ... Use
        <span class="bold"><strong>backup planning</strong></span>.</p></li><li class="listitem"><p><span class="emphasis"><em>Impossible to assign all entities now</em></span>: Leave some unassigned. For example: there are
        10 shifts at the same time to assign but only 9 employees to handle shifts. Use <span class="bold"><strong>overconstrained planning</strong></span>.</p></li><li class="listitem"><p><span class="emphasis"><em>Unknown long term future facts</em></span>: For example: The hospital admissions for the next 2
        weeks are reliable, but those for week 3 and 4 are less reliable and for week 5 and beyond are not worth
        planning yet. Use <span class="bold"><strong>continuous planning</strong></span>.</p></li><li class="listitem"><p><span class="emphasis"><em>Constantly changing problem facts</em></span>: Use <span class="bold"><strong>real-time
        planning</strong></span>.</p></li></ul></div><p>Waiting to start planning - to lower the risk of problem facts changing - usually isn't a good way to deal
    with that. More CPU time means a better planning solution. An incomplete plan is better than no plan.</p><p>Luckily, the optimization algorithms support planning a solution that's already (partially) planned, known as
    repeated planning.</p></div><div class="section" title="15.2. Backup Planning"><div class="titlepage"><div><div><h2 class="title"><a id="backupPlanning"/>15.2. Backup Planning</h2></div></div></div><p>Backup planning is the technique of adding extra score constraints to create space in the planning for when
    things go wrong. That creates a backup plan in the plan. For example: try to assign an employee as the spare
    employee (1 for every 10 shifts at the same time), keep 1 hospital bed open in each department, ...</p><p>Then, when things go wrong (one of the employees calls in sick), change the problem facts on the original
    solution (delete the sick employee leave his/her shifts unassigned) and just restart the planning, starting from
    that solution, which has a different score now. The construction heuristics will fill in the newly created gaps
    (probably with the spare employee) and the metaheuristics will even improve it further.</p></div><div class="section" title="15.3. Overconstrained Planning"><div class="titlepage"><div><div><h2 class="title"><a id="overconstrainedPlanning"/>15.3. Overconstrained Planning</h2></div></div></div><p>When there is no feasible solution to assign all planning entities, it's often desired to assign as many
    entities as possible without breaking hard constraints. This is called overconstrained planning.</p><div class="mediaobject"><img src="images/Chapter-Repeated_planning/overconstrainedPlanning.png"/></div><p>To implement this:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>Add a additional score level (usually a medium level between the hard and soft level) by switching <a class="link" href="ch05.html#scoreDefinition" title="5.2. Choose a Score Definition">ScoreDefinition</a>.</p></li><li class="listitem"><p>Make the planning variable <a class="link" href="ch04.html#nullablePlanningVariable" title="4.3.4.2. Nullable Planning Variable">nullable</a>.</p></li><li class="listitem"><p>Add a score constraint on the new level (so usually a medium constraint) to penalize the number of
        unassigned entities (or a weighted sum of them).</p></li></ol></div></div><div class="section" title="15.4. Continuous Planning (Windowed Planning)"><div class="titlepage"><div><div><h2 class="title"><a id="continuousPlanning"/>15.4. Continuous Planning (Windowed Planning)</h2></div></div></div><p>Continuous planning is the technique of planning one or more upcoming planning windows at the same time and
    repeating that process monthly, weekly, daily or hourly. Because time is infinite, there are infinite future
    windows, so planning all future windows is impossible. Instead, plan only a fixed number of upcoming planning
    windows.</p><p>Past planning windows are immutable. The first upcoming planning window is considered stable (unlikely to
    change), while later upcoming planning windows are considered draft (likely to change during the next planning
    effort). Distant future planning windows are not planned at all.</p><p>Past planning windows have only <span class="emphasis"><em>immovable</em></span> planning entities: the planning entities can no
    longer be changed (they are unable to move), but some of them are still needed in the score calculation, as they
    might affect some of the score constraints that apply on the upcoming planning entities. For example: when an
    employee should not work more than 5 days in a row, he shouldn't work today and tomorrow if he worked the past 4
    days already.</p><p>Sometimes some planning entities are semi-immovable: they can be changed, but occur a certain score penalty if
    they differ from their original place. For example: avoid rescheduling hospital beds less than 2 days before the
    patient arrives (unless it's really worth it), avoid changing the airplane gate during the 2 hours before boarding
    (unless there is no alternative), ...</p><div class="mediaobject"><img src="images/Chapter-Repeated_planning/continuousPlanningPatientAdmissionSchedule.png"/></div><p>Notice the difference between the original planning of November 1th and the new planning of November 5th: some
    problem facts (F, H, I, J, K) changed, which results in unrelated planning entities (G) changing too.</p><div class="section" title="15.4.1. Immovable Planning Entities"><div class="titlepage"><div><div><h3 class="title"><a id="immovablePlanningEntities"/>15.4.1. Immovable Planning Entities</h3></div></div></div><p>To make some planning entities immovable, simply add an entity <code class="literal">SelectionFilter</code> that
      returns <code class="literal">true</code> if an entity is movable and <code class="literal">false</code> if it is immovable.</p><pre><code class="language-java">public class MovableShiftAssignmentSelectionFilter implements SelectionFilter&lt;ShiftAssignment&gt; {

    public boolean accept(ScoreDirector scoreDirector, ShiftAssignment shiftAssignment) {
        ShiftDate shiftDate = shiftAssignment.getShift().getShiftDate();
        NurseRoster nurseRoster = (NurseRoster) scoreDirector.getWorkingSolution();
        return nurseRoster.getNurseRosterInfo().isInPlanningWindow(shiftDate);
    }

}</code></pre><p>And configure it like this:</p><pre><code class="language-java">@PlanningEntity(movableEntitySelectionFilter = MovableShiftAssignmentSelectionFilter.class)
public class ShiftAssignment {
    ...
}</code></pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>Custom <code class="literal">MoveListFactory</code> and <code class="literal">MoveIteratorFactory</code> implementations must
        make sure that they don't move immovable entities.</p></div></div><div class="section" title="15.4.2. Nonvolatile Replanning to minimize disruption (Semi-movable Planning Entities)"><div class="titlepage"><div><div><h3 class="title"><a id="nonvolatileReplanning"/>15.4.2. Nonvolatile Replanning to minimize disruption (Semi-movable Planning Entities)</h3></div></div></div><p>Replanning an existing plan can be very disruptive on the plan. If the plan affects humans (such as
      employees, drivers, ...), very disruptive changes are often undesirable. In such cases, nonvolatile replanning
      helps: the gain of changing a plan must be higher than the disruption it causes.</p><div class="mediaobject"><img src="images/Chapter-Repeated_planning/nonvolatileReplanning.png"/></div><p>For example, in the Machine Reassignment example, the entity has both the planning variable
      <code class="literal">machine</code> and its original value <code class="literal">originalMachine</code>:</p><pre><code class="language-java">@PlanningEntity(...)
public class ProcessAssignment {

    private MrProcess process;
    private Machine originalMachine;
    private Machine machine;

    public Machine getOriginalMachine() {...}

    @PlanningVariable(...)
    public Machine getMachine() {...}

    public boolean isMoved() {
        return originalMachine != null &amp;&amp; originalMachine != machine;
    }

    ...
}</code></pre><p>During planning, the planning variable <code class="literal">machine</code> changes. By comparing it with the
      originalMachine, a change in plan can be penalized:</p><pre><code class="no-highlight">rule "processMoved"
    when
        ProcessAssignment(moved == true)
    then
        scoreHolder.addSoftConstraintMatch(kcontext, -1000);
end</code></pre><p>The soft penalty of <code class="literal">-1000</code> means that a better solution is only accepted if it improves
      the soft score for at least <code class="literal">1000</code> points per variable changed (or if it improves the hard
      score).</p></div></div><div class="section" title="15.5. Real-time Planning"><div class="titlepage"><div><div><h2 class="title"><a id="realTimePlanning"/>15.5. Real-time Planning</h2></div></div></div><p>To do real-time planning, first combine <a class="link" href="ch15.html#backupPlanning" title="15.2. Backup Planning">backup planning</a> and <a class="link" href="ch15.html#continuousPlanning" title="15.4. Continuous Planning (Windowed Planning)">continuous planning</a> with short planning windows to lower the burden of real-time
    planning. As time passes, the problem itself changes:</p><div class="mediaobject"><img src="images/Chapter-Repeated_planning/realTimePlanningVehicleRouting.png"/></div><p>In the example above, 3 customers are added at different times (<code class="literal">07:56</code>,
    <code class="literal">08:02</code> and <code class="literal">08:45</code>), after the original customer set finished solving at
    <code class="literal">07:55</code> and in some cases after the vehicles already left. Planner can handle such scenario's with
    <code class="literal">ProblemFactChange</code> (in combination with <a class="link" href="ch15.html#immovablePlanningEntities" title="15.4.1. Immovable Planning Entities">immovable
    planning entities</a>).</p><div class="section" title="15.5.1. ProblemFactChange"><div class="titlepage"><div><div><h3 class="title"><a id="problemFactChange"/>15.5.1. <code class="literal">ProblemFactChange</code></h3></div></div></div><p>While the <code class="literal">Solver</code> is solving, an outside event might want to change one of the problem
      facts, for example an airplane is delayed and needs the runway at a later time. Do not change the problem fact
      instances used by the <code class="literal">Solver</code> while it is solving (from another thread or even in the same
      thread), as that will corrupt it. Instead, add a <code class="literal">ProblemFactChange</code> to the
      <code class="literal">Solver</code> which it will execute in the solver thread as soon as possible.</p><pre><code class="language-java">public interface Solver {

    ...

    boolean addProblemFactChange(ProblemFactChange problemFactChange);

    boolean isEveryProblemFactChangeProcessed();

    ...

}</code></pre><pre><code class="language-java">public interface ProblemFactChange {

    void doChange(ScoreDirector scoreDirector);

}</code></pre><p>Here's an example:</p><pre><code class="language-java">    public void deleteComputer(final CloudComputer computer) {
        solver.addProblemFactChange(new ProblemFactChange() {
            public void doChange(ScoreDirector scoreDirector) {
                CloudBalance cloudBalance = (CloudBalance) scoreDirector.getWorkingSolution();
                // First remove the problem fact from all planning entities that use it
                for (CloudProcess process : cloudBalance.getProcessList()) {
                    if (ObjectUtils.equals(process.getComputer(), computer)) {
                        scoreDirector.beforeVariableChanged(process, "computer");
                        process.setComputer(null);
                        scoreDirector.afterVariableChanged(process, "computer");
                    }
                }
                // A SolutionCloner does not clone problem fact lists (such as computerList)
                // Shallow clone the computerList so only workingSolution is affected, not bestSolution or guiSolution
                cloudBalance.setComputerList(new ArrayList&lt;CloudComputer&gt;(cloudBalance.getComputerList()));
                // Next remove it the problem fact itself
                for (Iterator&lt;CloudComputer&gt; it = cloudBalance.getComputerList().iterator(); it.hasNext(); ) {
                    CloudComputer workingComputer = it.next();
                    if (ObjectUtils.equals(workingComputer, computer)) {
                        scoreDirector.beforeProblemFactRemoved(workingComputer);
                        it.remove(); // remove from list
                        scoreDirector.afterProblemFactRemoved(workingComputer);
                        break;
                    }
                }
            }
        });
    }</code></pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>Any change on the problem facts or planning entities in a <code class="literal">ProblemFactChange</code> must be
        told to the <code class="literal">ScoreDirector</code>.</p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Important</h2><p>To write a <code class="literal">ProblemFactChange</code> correctly, it's important to understand the behaviour of
        <a class="link" href="ch04.html#cloningASolution" title="4.3.7.6. Cloning a Solution">a planning clone</a>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Any change in a <code class="literal">ProblemFactChange</code> must be done on the <code class="literal">Solution</code>
            instance of <code class="literal">scoreDirector.getWorkingSolution()</code>. The <code class="literal">workingSolution</code> is
            <a class="link" href="ch04.html#cloningASolution" title="4.3.7.6. Cloning a Solution">a planning clone</a> of the
            <code class="literal">BestSolutionChangedEvent</code>'s <code class="literal">bestSolution</code>. So the
            <code class="literal">workingSolution</code> in the <code class="literal">Solver</code> is never the same instance as the
            <code class="literal">Solution</code> in the rest of your application.</p></li><li class="listitem"><p>A planning clone also clones the planning entities and planning entity collections. So any change on
            the planning entities must happen on the instances hold by
            <code class="literal">scoreDirector.getWorkingSolution()</code>.</p></li><li class="listitem"><p>A planning clone does not clone the problem facts, nor the problem fact collections.
            <span class="emphasis"><em>Therefore the <code class="literal">workingSolution</code> and the <code class="literal">bestSolution</code> share the
            same problem fact instances and the same problem fact list instances.</em></span></p><p>Any problem fact or problem fact list changed by a <code class="literal">ProblemFactChange</code> must be
            problem cloned first (which can imply rerouting references in other problem facts and planning entities).
            Otherwise, if the <code class="literal">workingSolution</code> and <code class="literal">bestSolution</code> are used in
            different threads (for example a solver thread and a GUI event thread), a race condition can occur.</p></li></ul></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Many types of changes can leave a planning entity uninitialized, resulting in a partially initialized
        solution. That's fine, as long as the first solver phase can handle it. All construction heuristics solver
        phases can handle that, so it's recommended to configure such a solver phase as the first phase.</p></div><p>In essence, the <code class="literal">Solver</code> stops, runs the <code class="literal">ProblemFactChange</code> and <span class="bold"><strong>restarts</strong></span>. This is a <span class="emphasis"><em>warm start</em></span> because its initial solution is the
      adjusted best solution of the previous run. Each solver phase runs again. This implies the construction heuristic
      runs again, but because little or no planning variables are uninitialized (unless you have a <a class="link" href="ch04.html#nullablePlanningVariable" title="4.3.4.2. Nullable Planning Variable">nullable planning variable</a>), it finishes much quicker than in a cold
      start.</p><p>Each configured <code class="literal">Termination</code> resets (both in solver and phase configuration), but a
      previous call to <code class="literal">terminateEarly()</code> is not undone. Normally however, you won't configure any
      <code class="literal">Termination</code> (except in daemon mode), just call <code class="literal">Solver.terminateEarly()</code> when
      the results are needed. Alternatively, do configure a <code class="literal">Termination</code> and use the daemon mode in
      combination with <code class="literal"><a class="link" href="ch06.html#SolverEventListener" title="6.10. SolverEventListener">BestSolutionChangedEvent</a></code> as
      described below.</p></div><div class="section" title="15.5.2. Daemon: solve() Does Not Return"><div class="titlepage"><div><div><h3 class="title"><a id="daemon"/>15.5.2. Daemon: <code class="literal">solve()</code> Does Not Return</h3></div></div></div><p>In real-time planning, it's often useful to have a solver thread wait when it runs out of work, and
      immediately resume solving a problem once new problem fact changes are added. Putting the
      <code class="literal">Solver</code> in daemon mode has these effects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>If the <code class="literal">Solver</code>'s <code class="literal">Termination</code> terminates, it does not return from
          <code class="literal">solve()</code> but blocks its thread instead (which frees up CPU power).</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>Except for <code class="literal">terminateEarly()</code>, which does make it return from <code class="literal">solve()</code>, freeing up
              system resources and allowing an application to shutdown gracefully.</p></li><li class="listitem"><p>If a <code class="literal">Solver</code> starts with an empty planning entity collection, it waits in the
              blocked state immediately.</p></li></ul></div></li><li class="listitem"><p>If a <code class="literal">ProblemFactChange</code> is added, it goes into the running state, applies the
          <code class="literal">ProblemFactChange</code> and runs the <code class="literal">Solver</code> again.</p></li></ul></div><p>To configure the daemon mode:</p><pre><code class="language-xml">&lt;solver&gt;
  &lt;daemon&gt;true&lt;/daemon&gt;
  ...
&lt;/solver&gt;</code></pre><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>Don't forget to call <code class="literal">Solver.terminateEarly()</code> when your application needs to shutdown to
        avoid killing the solver thread unnaturally.</p></div><p>Subscribe to the <code class="literal"><a class="link" href="ch06.html#SolverEventListener" title="6.10. SolverEventListener">BestSolutionChangedEvent</a></code> to
      process new best solutions found by the solver thread. A <code class="literal">BestSolutionChangedEvent</code> doesn't
      guarantee that every <code class="literal">ProblemFactChange</code> has been processed already, nor that the solution is
      initialized and feasible. To ignore <code class="literal">BestSolutionChangedEvent</code>s with such invalid solutions, do
      this:</p><pre><code class="language-java">    public void bestSolutionChanged(BestSolutionChangedEvent&lt;CloudBalance&gt; event) {
        // Ignore invalid solutions
        if (event.isEveryProblemFactChangeProcessed()
                &amp;&amp; event.isNewBestSolutionInitialized()
                &amp;&amp; event.getNewBestSolution().getScore().isFeasible()) {
            ...
        }
    }</code></pre></div></div></div><script type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script type="text/javascript">hljs.initHighlightingOnLoad();</script><script type="text/javascript">
dataLayer = [{'channel' : 'OptaPlanner', 'additional_tracking_code' : 'UA-39485370-1'}];
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NJWS5L');</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-NJWS5L" height="0" width="0" style="display:none;visibility:hidden"> </iframe></noscript><ul class="docnav"><li class="previous"><a accesskey="p" href="ch14.html"><strong>Prev</strong>Chapter 14. Benchmarking And Tweaking</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch16.html"><strong>Next</strong>Chapter 16. Integration</a></li></ul></body></html>